// Code generated by protoc-gen-go. DO NOT EDIT.
// source: gonverter.proto

package gonverter

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ARGB32 struct {
	Argb                 uint32   `protobuf:"varint,1,opt,name=argb,proto3" json:"argb,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ARGB32) Reset()         { *m = ARGB32{} }
func (m *ARGB32) String() string { return proto.CompactTextString(m) }
func (*ARGB32) ProtoMessage()    {}
func (*ARGB32) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7a6ed7f4dff86cc, []int{0}
}

func (m *ARGB32) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ARGB32.Unmarshal(m, b)
}
func (m *ARGB32) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ARGB32.Marshal(b, m, deterministic)
}
func (m *ARGB32) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ARGB32.Merge(m, src)
}
func (m *ARGB32) XXX_Size() int {
	return xxx_messageInfo_ARGB32.Size(m)
}
func (m *ARGB32) XXX_DiscardUnknown() {
	xxx_messageInfo_ARGB32.DiscardUnknown(m)
}

var xxx_messageInfo_ARGB32 proto.InternalMessageInfo

func (m *ARGB32) GetArgb() uint32 {
	if m != nil {
		return m.Argb
	}
	return 0
}

type RGBA32 struct {
	Rgba                 uint32   `protobuf:"varint,1,opt,name=rgba,proto3" json:"rgba,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RGBA32) Reset()         { *m = RGBA32{} }
func (m *RGBA32) String() string { return proto.CompactTextString(m) }
func (*RGBA32) ProtoMessage()    {}
func (*RGBA32) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7a6ed7f4dff86cc, []int{1}
}

func (m *RGBA32) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RGBA32.Unmarshal(m, b)
}
func (m *RGBA32) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RGBA32.Marshal(b, m, deterministic)
}
func (m *RGBA32) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RGBA32.Merge(m, src)
}
func (m *RGBA32) XXX_Size() int {
	return xxx_messageInfo_RGBA32.Size(m)
}
func (m *RGBA32) XXX_DiscardUnknown() {
	xxx_messageInfo_RGBA32.DiscardUnknown(m)
}

var xxx_messageInfo_RGBA32 proto.InternalMessageInfo

func (m *RGBA32) GetRgba() uint32 {
	if m != nil {
		return m.Rgba
	}
	return 0
}

type ARGB64 struct {
	Argb                 uint64   `protobuf:"varint,1,opt,name=argb,proto3" json:"argb,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ARGB64) Reset()         { *m = ARGB64{} }
func (m *ARGB64) String() string { return proto.CompactTextString(m) }
func (*ARGB64) ProtoMessage()    {}
func (*ARGB64) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7a6ed7f4dff86cc, []int{2}
}

func (m *ARGB64) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ARGB64.Unmarshal(m, b)
}
func (m *ARGB64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ARGB64.Marshal(b, m, deterministic)
}
func (m *ARGB64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ARGB64.Merge(m, src)
}
func (m *ARGB64) XXX_Size() int {
	return xxx_messageInfo_ARGB64.Size(m)
}
func (m *ARGB64) XXX_DiscardUnknown() {
	xxx_messageInfo_ARGB64.DiscardUnknown(m)
}

var xxx_messageInfo_ARGB64 proto.InternalMessageInfo

func (m *ARGB64) GetArgb() uint64 {
	if m != nil {
		return m.Argb
	}
	return 0
}

type RGBA64 struct {
	Rgba                 uint64   `protobuf:"varint,1,opt,name=rgba,proto3" json:"rgba,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RGBA64) Reset()         { *m = RGBA64{} }
func (m *RGBA64) String() string { return proto.CompactTextString(m) }
func (*RGBA64) ProtoMessage()    {}
func (*RGBA64) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7a6ed7f4dff86cc, []int{3}
}

func (m *RGBA64) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RGBA64.Unmarshal(m, b)
}
func (m *RGBA64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RGBA64.Marshal(b, m, deterministic)
}
func (m *RGBA64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RGBA64.Merge(m, src)
}
func (m *RGBA64) XXX_Size() int {
	return xxx_messageInfo_RGBA64.Size(m)
}
func (m *RGBA64) XXX_DiscardUnknown() {
	xxx_messageInfo_RGBA64.DiscardUnknown(m)
}

var xxx_messageInfo_RGBA64 proto.InternalMessageInfo

func (m *RGBA64) GetRgba() uint64 {
	if m != nil {
		return m.Rgba
	}
	return 0
}

func init() {
	proto.RegisterType((*ARGB32)(nil), "gonverter.ARGB32")
	proto.RegisterType((*RGBA32)(nil), "gonverter.RGBA32")
	proto.RegisterType((*ARGB64)(nil), "gonverter.ARGB64")
	proto.RegisterType((*RGBA64)(nil), "gonverter.RGBA64")
}

func init() { proto.RegisterFile("gonverter.proto", fileDescriptor_b7a6ed7f4dff86cc) }

var fileDescriptor_b7a6ed7f4dff86cc = []byte{
	// 163 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4f, 0xcf, 0xcf, 0x2b,
	0x4b, 0x2d, 0x2a, 0x49, 0x2d, 0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x84, 0x0b, 0x28,
	0xc9, 0x70, 0xb1, 0x39, 0x06, 0xb9, 0x3b, 0x19, 0x1b, 0x09, 0x09, 0x71, 0xb1, 0x24, 0x16, 0xa5,
	0x27, 0x49, 0x30, 0x2a, 0x30, 0x6a, 0xf0, 0x06, 0x81, 0xd9, 0x20, 0xd9, 0x20, 0x77, 0x27, 0x47,
	0x88, 0x6c, 0x51, 0x7a, 0x52, 0x22, 0x4c, 0x16, 0xc4, 0x86, 0xe9, 0x35, 0x33, 0x41, 0xd1, 0xcb,
	0x82, 0xaa, 0x17, 0x22, 0x0b, 0xd7, 0xcb, 0x02, 0xd1, 0x6b, 0xd4, 0xcf, 0xc8, 0xc5, 0xe9, 0xee,
	0x0f, 0x75, 0x85, 0x90, 0x03, 0x97, 0x90, 0x33, 0xc4, 0x49, 0x20, 0x03, 0xe3, 0xa1, 0x76, 0x0a,
	0xea, 0x21, 0x1c, 0x0e, 0x71, 0xa4, 0x14, 0xb2, 0x10, 0x44, 0x95, 0x12, 0x83, 0x06, 0xa3, 0x01,
	0x23, 0x36, 0x13, 0xcc, 0x4c, 0x30, 0x4c, 0x30, 0x33, 0xc1, 0x30, 0xc1, 0xcc, 0x04, 0x62, 0x42,
	0x12, 0x1b, 0x38, 0x6c, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa4, 0x6a, 0x23, 0x8d, 0x2e,
	0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GOnverterClient is the client API for GOnverter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GOnverterClient interface {
	ConvertARGB_RGBA32(ctx context.Context, opts ...grpc.CallOption) (GOnverter_ConvertARGB_RGBA32Client, error)
	ConvertARGB_RGBA64(ctx context.Context, opts ...grpc.CallOption) (GOnverter_ConvertARGB_RGBA64Client, error)
}

type gOnverterClient struct {
	cc *grpc.ClientConn
}

func NewGOnverterClient(cc *grpc.ClientConn) GOnverterClient {
	return &gOnverterClient{cc}
}

func (c *gOnverterClient) ConvertARGB_RGBA32(ctx context.Context, opts ...grpc.CallOption) (GOnverter_ConvertARGB_RGBA32Client, error) {
	stream, err := c.cc.NewStream(ctx, &_GOnverter_serviceDesc.Streams[0], "/gonverter.GOnverter/ConvertARGB_RGBA32", opts...)
	if err != nil {
		return nil, err
	}
	x := &gOnverterConvertARGB_RGBA32Client{stream}
	return x, nil
}

type GOnverter_ConvertARGB_RGBA32Client interface {
	Send(*ARGB32) error
	Recv() (*RGBA32, error)
	grpc.ClientStream
}

type gOnverterConvertARGB_RGBA32Client struct {
	grpc.ClientStream
}

func (x *gOnverterConvertARGB_RGBA32Client) Send(m *ARGB32) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gOnverterConvertARGB_RGBA32Client) Recv() (*RGBA32, error) {
	m := new(RGBA32)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gOnverterClient) ConvertARGB_RGBA64(ctx context.Context, opts ...grpc.CallOption) (GOnverter_ConvertARGB_RGBA64Client, error) {
	stream, err := c.cc.NewStream(ctx, &_GOnverter_serviceDesc.Streams[1], "/gonverter.GOnverter/ConvertARGB_RGBA64", opts...)
	if err != nil {
		return nil, err
	}
	x := &gOnverterConvertARGB_RGBA64Client{stream}
	return x, nil
}

type GOnverter_ConvertARGB_RGBA64Client interface {
	Send(*ARGB64) error
	Recv() (*RGBA64, error)
	grpc.ClientStream
}

type gOnverterConvertARGB_RGBA64Client struct {
	grpc.ClientStream
}

func (x *gOnverterConvertARGB_RGBA64Client) Send(m *ARGB64) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gOnverterConvertARGB_RGBA64Client) Recv() (*RGBA64, error) {
	m := new(RGBA64)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GOnverterServer is the server API for GOnverter service.
type GOnverterServer interface {
	ConvertARGB_RGBA32(GOnverter_ConvertARGB_RGBA32Server) error
	ConvertARGB_RGBA64(GOnverter_ConvertARGB_RGBA64Server) error
}

func RegisterGOnverterServer(s *grpc.Server, srv GOnverterServer) {
	s.RegisterService(&_GOnverter_serviceDesc, srv)
}

func _GOnverter_ConvertARGB_RGBA32_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GOnverterServer).ConvertARGB_RGBA32(&gOnverterConvertARGB_RGBA32Server{stream})
}

type GOnverter_ConvertARGB_RGBA32Server interface {
	Send(*RGBA32) error
	Recv() (*ARGB32, error)
	grpc.ServerStream
}

type gOnverterConvertARGB_RGBA32Server struct {
	grpc.ServerStream
}

func (x *gOnverterConvertARGB_RGBA32Server) Send(m *RGBA32) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gOnverterConvertARGB_RGBA32Server) Recv() (*ARGB32, error) {
	m := new(ARGB32)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GOnverter_ConvertARGB_RGBA64_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GOnverterServer).ConvertARGB_RGBA64(&gOnverterConvertARGB_RGBA64Server{stream})
}

type GOnverter_ConvertARGB_RGBA64Server interface {
	Send(*RGBA64) error
	Recv() (*ARGB64, error)
	grpc.ServerStream
}

type gOnverterConvertARGB_RGBA64Server struct {
	grpc.ServerStream
}

func (x *gOnverterConvertARGB_RGBA64Server) Send(m *RGBA64) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gOnverterConvertARGB_RGBA64Server) Recv() (*ARGB64, error) {
	m := new(ARGB64)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GOnverter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gonverter.GOnverter",
	HandlerType: (*GOnverterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ConvertARGB_RGBA32",
			Handler:       _GOnverter_ConvertARGB_RGBA32_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ConvertARGB_RGBA64",
			Handler:       _GOnverter_ConvertARGB_RGBA64_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "gonverter.proto",
}
